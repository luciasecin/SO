Ejercicio 1

A continuación se muestran procesos que son ejecutados concurrentemente. 
La variable X es compartida y se inicializa en 0. 
No hay información acerca de cómo serán ejecutados por el scheduler.
    
    Proceso A:
        X = X + 1;
        printf(" % d", X);
    Proceso B:
        X = X + 1;

a) ¿Hay una única salida en pantalla posible?
No, ya que puede suceder que B sume 1 a X antes que A lo haga o viceversa.

b) Si existen varias opciones, indicar todas las salidas posibles.
Las posibles salidas son Uno o Dos. Existe la opcion de que el print suceda antes de que B sume uno a X, entonces
por pantalla se muestra el Uno, o que el print suceda luego de que B sume uno, entonces se imprimira dos por pantalla.

--------------------------------------------------------------------------------------------------------------------

Ejercicio 2

Ídem ejercicio anterior. Las variables X e Y son compartidas y se inicializan en 0.
    Proceso A:
        for (; X < 4; X++) {
            Y = 0;
            printf(" % d", X);
            Y = 1;
        }
    Proceso B:
        while (X < 4) {
            if (Y == 1)
            printf("a");
        }

a) ¿Hay una única salida en pantalla posible?
No, si bien existe la Y como "variable de control" y el B no cambia variables de A. 
Aunque el A siempre imprima 0,1,2,3, y el B siempre imprima "a", puede variar el orden en el que se imprimen 
y tambien la cantidad de "a" que se imprimen.

b) Si existen varias opciones, indicar todas las salidas posibles.
Existen muchas posibilidades disintas, en todas se imprimen el 0,1,2 y 3 pero con disintas cantidades de "a"
en el medio. Salidas observadas pero no las unicas: 0 1 a2 3 // 0 1 2 3 // 0 1 2 3a

-------------------------------------------------------------------------------------------------------------------

Ejercicio 3

Se tiene un sistema con cuatro procesos accediendo a una variable compartida y un mutex. Del
valor de la variable dependerán ciertas decisiones que tome cada proceso. Nos aseguran que cada vez
que un proceso lee de la variable compartida, previamente se solicita el mutex y luego lo libera. ¿Es
posible escribir procesos que cumplan con estas características, pero que puedan ser víctimas de una
race condition?

Si solo se lee la variable dentro del mutex pero se modifica fuera, entonces si. 
En cambio, si la variable solo es leida y modificada dentro del mutex, no hay race condition.